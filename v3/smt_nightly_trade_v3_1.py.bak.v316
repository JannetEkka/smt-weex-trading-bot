"""
SMT Nightly Trade V3.1.6 - Tier-Based Multi-Persona Analysis
=============================================================
Enhanced trading with tier-based risk management.

V3.1.4 Changes (CRITICAL FIXES):
- Reduced MAX_OPEN_POSITIONS from 8 to 5 (less exposure)
- Increased MIN_CONFIDENCE_TO_TRADE from 55% to 65% (better signals)
- Widened Tier 3 SL from 1.5% to 2.0% (stop getting whipsawed)
- Increased Tier 3 TP from 2.5% to 3.0% (better R:R ratio)
- Added MARKET TREND FILTER - don't go LONG when BTC is dropping!
- Reduced Tier 3 max hold from 6h to 4h (faster exits)

V3.1.3 Changes:
- Fixed explanation truncation: 2500 chars (500 words) instead of 500 chars

Tier Config:
- Tier 1 (BTC, ETH, BNB, LTC): 4% TP, 2% SL, 48h hold
- Tier 2 (SOL): 3% TP, 1.75% SL, 12h hold  
- Tier 3 (DOGE, XRP, ADA): 3% TP, 2% SL, 4h hold (UPDATED!)

Personas:
1. WHALE - On-chain whale intelligence (our unique edge)
2. SENTIMENT - Market sentiment via Gemini search
3. FLOW - Order flow analysis (taker ratio + depth)
4. TECHNICAL - RSI, SMA, momentum indicators
5. JUDGE - Final validator that weighs all personas + MARKET TREND

Run: python3 smt_nightly_trade_v3_1.py
Test: python3 smt_nightly_trade_v3_1.py --test
"""

import os
import sys
import json
import time
import hmac
import hashlib
import base64
import pickle
import requests
import numpy as np
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Tuple

# ============================================================
# CONFIGURATION
# ============================================================

TEST_MODE = "--test" in sys.argv or os.getenv("SMT_TEST_MODE", "false").lower() == "true"
SIMULATED_BALANCE = 1000.0

# WEEX API
WEEX_API_KEY = os.getenv('WEEX_API_KEY', 'weex_cda1971e60e00a1f6ce7393c1fa2cf86')
WEEX_API_SECRET = os.getenv('WEEX_API_SECRET', '15068d295eb937704e13b07f75f34ce30b6e279ec1e19bff44558915ef0d931c')
WEEX_API_PASSPHRASE = os.getenv('WEEX_API_PASSPHRASE', 'weex8282888')
WEEX_BASE_URL = "https://api-contract.weex.com"

# Etherscan
ETHERSCAN_API_KEY = os.getenv('ETHERSCAN_API_KEY', 'W7GTUDUM9BMBQPJUZXXMDBJH4JDPUQS9UR')
ETHERSCAN_BASE_URL = "https://api.etherscan.io/v2/api"
CHAIN_ID = 1

# Google Cloud
PROJECT_ID = os.getenv('GOOGLE_CLOUD_PROJECT', 'smt-weex-2025')
GCS_BUCKET = os.getenv('GCS_BUCKET', 'smt-weex-2025-models')

# Competition
COMPETITION_START = datetime(2026, 1, 12, tzinfo=timezone.utc)
COMPETITION_END = datetime(2026, 2, 2, tzinfo=timezone.utc)
STARTING_BALANCE = 1000.0
FLOOR_BALANCE = 950.0  # Protect principal - stop trading below this

# Trading Parameters - V3.1.4 UPDATES
MAX_LEVERAGE = 20
MAX_OPEN_POSITIONS = 8  # REDUCED from 8 - less exposure, better management
MAX_SINGLE_POSITION_PCT = 0.08  # 8% per trade max
MIN_SINGLE_POSITION_PCT = 0.03  # 3% minimum
MIN_CONFIDENCE_TO_TRADE = 0.65  # INCREASED from 0.55 - stop taking weak signals!

# ============================================================
# V3.1.4: TIER-BASED PARAMETERS (UPDATED!)
# ============================================================
# Tier 1: Stable (BTC, ETH, BNB, LTC) - slow grind, need room to breathe
# Tier 2: Mid volatility (SOL) - volatile but not meme-tier
# Tier 3: Fast/Meme (DOGE, XRP, ADA) - WIDENED SL to stop whipsaw losses

TIER_CONFIG = {
    1: {  # BTC, ETH, BNB, LTC - Stable, slow movers
        "name": "STABLE",
        "tp_pct": 4.0,           # Take profit at 4%
        "sl_pct": 2.0,           # Stop loss at 2%
        "max_hold_hours": 48,    # Allow 48h for slow grind
        "early_exit_hours": 6,   # Check early exit after 6h
        "early_exit_loss_pct": -1.5,  # Exit if -1.5% after 6h
        "force_exit_loss_pct": -4.0,  # Hard stop at -4%
    },
    2: {  # SOL - Mid volatility
        "name": "MID",
        "tp_pct": 3.0,           # Take profit at 3%
        "sl_pct": 1.75,          # Stop loss at 1.75%
        "max_hold_hours": 12,    # 12h max hold
        "early_exit_hours": 3,   # Check early exit after 3h
        "early_exit_loss_pct": -1.5,  # Exit if -1.5% after 3h
        "force_exit_loss_pct": -4.0,  # Hard stop at -4%
    },
    3: {  # DOGE, XRP, ADA - V3.1.4: WIDENED SL, HIGHER TP
        "name": "FAST",
        "tp_pct": 3.0,           # INCREASED from 2.5% - better R:R
        "sl_pct": 2.0,           # INCREASED from 1.5% - stop getting whipsawed!
        "max_hold_hours": 12,  # V3.1.6: Extended from 4h     # REDUCED from 6h - get out faster
        "early_exit_hours": 4,  # V3.1.6: Extended from 1.5h # REDUCED from 2h - check earlier
        "early_exit_loss_pct": -1.5,  # V3.1.6: More room  # Exit if -1% after 1.5h
        "force_exit_loss_pct": -4.0,  # Hard stop at -4%
    },
}

# Trading Pairs with correct tiers
TRADING_PAIRS = {
    "BTC": {"symbol": "cmt_btcusdt", "tier": 1, "has_whale_data": True},
    "ETH": {"symbol": "cmt_ethusdt", "tier": 1, "has_whale_data": True},
    "BNB": {"symbol": "cmt_bnbusdt", "tier": 1, "has_whale_data": False},
    "LTC": {"symbol": "cmt_ltcusdt", "tier": 1, "has_whale_data": False},
    "SOL": {"symbol": "cmt_solusdt", "tier": 2, "has_whale_data": False},
    "DOGE": {"symbol": "cmt_dogeusdt", "tier": 3, "has_whale_data": False},
    "XRP": {"symbol": "cmt_xrpusdt", "tier": 3, "has_whale_data": False},
    "ADA": {"symbol": "cmt_adausdt", "tier": 3, "has_whale_data": False},
}

# Pipeline Version
PIPELINE_VERSION = "SMT-v3.1.6-MultiPersonaAgreement"
MODEL_NAME = "CatBoost-Gemini-MultiPersona-v3.1.6"

# Known step sizes
KNOWN_STEP_SIZES = {
    "cmt_btcusdt": 0.0001,
    "cmt_ethusdt": 0.01,
    "cmt_solusdt": 0.1,
    "cmt_dogeusdt": 100,
    "cmt_xrpusdt": 10,
    "cmt_adausdt": 10,
    "cmt_bnbusdt": 0.1,
    "cmt_ltcusdt": 0.1,
}

CEX_ADDRESSES = {
    "0x28c6c06298d514db089934071355e5743bf21d60": "Binance",
    "0x21a31ee1afc51d94c2efccaa2092ad1028285549": "Binance",
    "0xdfd5293d8e347dfe59e90efd55b2956a1343963d": "Binance",
    "0xf977814e90da44bfa03b6295a0616a897441acec": "Binance",
}

CONTRACT_INFO_CACHE = {}


# ============================================================
# TIER HELPER FUNCTIONS
# ============================================================

def get_tier_for_symbol(symbol: str) -> int:
    """Get tier number for a symbol (e.g., 'cmt_btcusdt' -> 1)"""
    for pair_name, pair_info in TRADING_PAIRS.items():
        if pair_info["symbol"] == symbol:
            return pair_info.get("tier", 2)
    return 2  # Default to mid tier


def get_tier_for_pair(pair_name: str) -> int:
    """Get tier number for a pair name (e.g., 'BTC' -> 1)"""
    if pair_name in TRADING_PAIRS:
        return TRADING_PAIRS[pair_name].get("tier", 2)
    return 2


def get_tier_config(tier: int) -> Dict:
    """Get tier configuration"""
    return TIER_CONFIG.get(tier, TIER_CONFIG[2])


def get_tier_config_for_symbol(symbol: str) -> Dict:
    """Get tier config for a symbol"""
    tier = get_tier_for_symbol(symbol)
    return get_tier_config(tier)


def get_tier_config_for_pair(pair_name: str) -> Dict:
    """Get tier config for a pair name"""
    tier = get_tier_for_pair(pair_name)
    return get_tier_config(tier)


# ============================================================
# WEEX API HELPERS
# ============================================================

def weex_sign(timestamp: str, method: str, path: str, body: str = "") -> str:
    message = timestamp + method.upper() + path + body
    sig = hmac.new(WEEX_API_SECRET.encode(), message.encode(), hashlib.sha256).digest()
    return base64.b64encode(sig).decode()


def weex_headers(method: str, path: str, body: str = "") -> Dict:
    ts = str(int(time.time() * 1000))
    return {
        "ACCESS-KEY": WEEX_API_KEY,
        "ACCESS-SIGN": weex_sign(ts, method, path, body),
        "ACCESS-TIMESTAMP": ts,
        "ACCESS-PASSPHRASE": WEEX_API_PASSPHRASE,
        "Content-Type": "application/json"
    }


def get_price(symbol: str) -> float:
    try:
        r = requests.get(f"{WEEX_BASE_URL}/capi/v2/market/ticker?symbol={symbol}", timeout=10)
        return float(r.json().get("last", 0))
    except:
        return 0.0


def get_balance() -> float:
    """Get available USDT balance from WEEX"""
    try:
        endpoint = "/capi/v2/account/assets"
        r = requests.get(f"{WEEX_BASE_URL}{endpoint}", headers=weex_headers("GET", endpoint), timeout=15)
        data = r.json()
        
        if isinstance(data, list):
            for asset in data:
                if asset.get("coinName") == "USDT":
                    available = float(asset.get("available", 0))
                    if available > 0:
                        return available
        
        endpoint2 = "/capi/v2/account/accounts"
        r2 = requests.get(f"{WEEX_BASE_URL}{endpoint2}", headers=weex_headers("GET", endpoint2), timeout=15)
        data2 = r2.json()
        if "collateral" in data2 and len(data2["collateral"]) > 0:
            amount = float(data2["collateral"][0].get("amount", 0))
            if amount > 0:
                return amount
        
        if TEST_MODE:
            return SIMULATED_BALANCE
        return SIMULATED_BALANCE
    except Exception as e:
        print(f"  [ERROR] get_balance: {e}")
        return SIMULATED_BALANCE


def get_open_positions() -> List[Dict]:
    try:
        endpoint = "/capi/v2/account/position/allPosition"
        r = requests.get(f"{WEEX_BASE_URL}{endpoint}", headers=weex_headers("GET", endpoint), timeout=15)
        data = r.json()
        positions = []
        if isinstance(data, list):
            for pos in data:
                size = float(pos.get("size", 0))
                if size > 0:
                    margin = float(pos.get("marginSize", 0))
                    open_value = float(pos.get("open_value", 0))
                    entry_price = open_value / size if size > 0 else 0
                    positions.append({
                        "symbol": pos.get("symbol"),
                        "side": pos.get("side", "").upper(),
                        "size": size,
                        "entry_price": entry_price,
                        "unrealized_pnl": float(pos.get("unrealizePnl", 0)),
                        "margin": margin,
                    })
        return positions
    except:
        return []


def get_contract_info(symbol: str) -> Dict:
    global CONTRACT_INFO_CACHE
    if symbol in CONTRACT_INFO_CACHE:
        return CONTRACT_INFO_CACHE[symbol]
    try:
        r = requests.get(f"{WEEX_BASE_URL}/capi/v2/market/contracts?symbol={symbol}", timeout=10)
        data = r.json()
        if isinstance(data, list) and len(data) > 0:
            info = data[0]
            step_size = KNOWN_STEP_SIZES.get(symbol, 0.001)
            contract_info = {
                "symbol": symbol,
                "tick_size": info.get("tick_size", "2"),
                "min_order_size": float(info.get("minOrderSize", "0.001")),
                "step_size": step_size,
            }
            CONTRACT_INFO_CACHE[symbol] = contract_info
            return contract_info
    except:
        pass
    return {"symbol": symbol, "step_size": KNOWN_STEP_SIZES.get(symbol, 0.001), "tick_size": "2"}


def round_size_to_step(size: float, symbol: str) -> float:
    """Round size DOWN to nearest step"""
    contract_info = get_contract_info(symbol)
    step = contract_info.get("step_size", 0.001)
    
    import math
    floored = math.floor(size / step) * step
    
    if step >= 1:
        return int(floored)
    else:
        decimals = len(str(step).split('.')[-1]) if '.' in str(step) else 0
        return round(floored, decimals)


def round_price_to_tick(price: float, symbol: str) -> float:
    contract_info = get_contract_info(symbol)
    tick_size = int(contract_info.get("tick_size", "2"))
    return round(price, tick_size)


# ============================================================
# PERSONA 1: WHALE INTELLIGENCE (FIXED - Actually uses data!)
# ============================================================

# Top whales to monitor (from our dataset - highest ETH holders)
TOP_WHALES = [
    {"address": "0x47ac0fb4f2d84898e4d9e7b4dab3c24507a6d503", "label": "SushiSwap Whale", "balance": 554999},
    {"address": "0xf977814e90da44bfa03b6295a0616a897441acec", "label": "Binance Hot", "balance": 538622},
    {"address": "0x28c6c06298d514db089934071355e5743bf21d60", "label": "Binance Main", "balance": 159563},
    {"address": "0x21a31ee1afc51d94c2efccaa2092ad1028285549", "label": "Binance 2", "balance": 24971},
    {"address": "0xdfd5293d8e347dfe59e90efd55b2956a1343963d", "label": "Binance 3", "balance": 15215},
    {"address": "0x1d5a591eebb5bcb20f440d121e4f62e8d1689997", "label": "DEX Whale", "balance": 20753},
    {"address": "0xee1bf4d7c53af2beafc7dc1dcea222a8c6d87ad9", "label": "DEX Trader", "balance": 40086},
    {"address": "0x73af3bcf944a6559933396c1577b257e2054d935", "label": "Aave Whale", "balance": 303067},
]

class WhalePersona:
    """
    Analyzes on-chain whale behavior for ETH/BTC signals.
    Tracks large wallet movements via Etherscan API.
    """
    
    def __init__(self):
        self.name = "WHALE"
        self.weight = 2.0
        self.cache = {}
        self.cache_ttl = 300  # 5 minutes
    
    def analyze(self, pair: str, pair_info: Dict) -> Dict:
        """Analyze whale activity for trading signal"""
        
        if pair not in ("ETH", "BTC"):
            return {
                "persona": self.name,
                "signal": "NEUTRAL",
                "confidence": 0.0,
                "reasoning": f"No whale data for {pair}",
            }
        
        try:
            # Analyze top whales
            total_inflow = 0
            total_outflow = 0
            whale_signals = []
            whales_analyzed = 0
            
            for whale in TOP_WHALES[:5]:  # Check top 5 whales
                try:
                    flow = self._analyze_whale_flow(whale["address"], whale["label"])
                    if flow:
                        whales_analyzed += 1
                        total_inflow += flow["inflow"]
                        total_outflow += flow["outflow"]
                        
                        if flow["net"] > 100:  # Significant inflow (>100 ETH)
                            whale_signals.append(f"{whale['label']}: +{flow['net']:.0f} ETH")
                        elif flow["net"] < -100:  # Significant outflow
                            whale_signals.append(f"{whale['label']}: {flow['net']:.0f} ETH")
                    
                    time.sleep(0.25)  # Rate limit Etherscan
                except Exception as e:
                    print(f"  [WHALE] Error analyzing {whale['label']}: {e}")
                    continue
            
            if whales_analyzed == 0:
                return {
                    "persona": self.name,
                    "signal": "NEUTRAL",
                    "confidence": 0.3,
                    "reasoning": "Could not fetch whale data from Etherscan",
                }
            
            net_flow = total_inflow - total_outflow
            
            # Determine signal based on net flow
            if net_flow > 500:  # Strong accumulation (>500 ETH net inflow)
                signal = "LONG"
                confidence = min(0.85, 0.5 + (net_flow / 5000))
                reasoning = f"Whale accumulation: +{net_flow:.0f} ETH net inflow"
            elif net_flow < -500:  # Strong distribution (>500 ETH net outflow)
                signal = "SHORT"
                confidence = min(0.85, 0.5 + (abs(net_flow) / 5000))
                reasoning = f"Whale distribution: {net_flow:.0f} ETH net outflow"
            elif net_flow > 100:  # Mild accumulation
                signal = "LONG"
                confidence = 0.55
                reasoning = f"Mild whale accumulation: +{net_flow:.0f} ETH"
            elif net_flow < -100:  # Mild distribution
                signal = "SHORT"
                confidence = 0.55
                reasoning = f"Mild whale distribution: {net_flow:.0f} ETH"
            else:
                signal = "NEUTRAL"
                confidence = 0.4
                reasoning = f"Whale activity balanced: {net_flow:+.0f} ETH"
            
            if whale_signals:
                reasoning += f" | {'; '.join(whale_signals[:3])}"
            
            return {
                "persona": self.name,
                "signal": signal,
                "confidence": confidence,
                "reasoning": reasoning,
                "data": {
                    "net_flow": net_flow,
                    "inflow": total_inflow,
                    "outflow": total_outflow,
                    "whales_analyzed": whales_analyzed,
                },
            }
            
        except Exception as e:
            return {
                "persona": self.name,
                "signal": "NEUTRAL",
                "confidence": 0.0,
                "reasoning": f"Whale analysis error: {str(e)}",
            }
    
    def _analyze_whale_flow(self, address: str, label: str) -> Optional[Dict]:
        """Fetch recent transactions for a whale and calculate flow"""
        
        # Check cache
        cache_key = f"{address}_{int(time.time() // self.cache_ttl)}"
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        try:
            # Fetch recent transactions from Etherscan
            params = {
                "chainid": CHAIN_ID,
                "module": "account",
                "action": "txlist",
                "address": address,
                "page": 1,
                "offset": 50,  # Last 50 transactions
                "sort": "desc",
                "apikey": ETHERSCAN_API_KEY,
            }
            
            r = requests.get(ETHERSCAN_BASE_URL, params=params, timeout=15)
            data = r.json()
            
            if data.get("status") != "1" or not data.get("result"):
                return None
            
            # Calculate flow in last 24 hours
            cutoff = time.time() - (24 * 3600)
            inflow = 0
            outflow = 0
            
            for tx in data["result"]:
                tx_time = int(tx.get("timeStamp", 0))
                if tx_time < cutoff:
                    continue
                
                value_eth = float(tx.get("value", 0)) / 1e18
                
                if value_eth < 1:  # Ignore small transactions
                    continue
                
                if tx.get("to", "").lower() == address.lower():
                    inflow += value_eth
                elif tx.get("from", "").lower() == address.lower():
                    outflow += value_eth
            
            result = {
                "address": address,
                "label": label,
                "inflow": inflow,
                "outflow": outflow,
                "net": inflow - outflow,
            }
            
            # Cache result
            self.cache[cache_key] = result
            return result
            
        except Exception as e:
            print(f"  [WHALE] Etherscan error for {label}: {e}")
            return None


# ============================================================
# PERSONA 2: MARKET SENTIMENT (Gemini)
# ============================================================

class SentimentPersona:
    """Uses Gemini with Google Search grounding for market sentiment."""
    
    def __init__(self):
        self.name = "SENTIMENT"
        self.weight = 1.5  # V3.1.6: Reduced from 2.0
    
    def analyze(self, pair: str, pair_info: Dict, competition_status: Dict) -> Dict:
        try:
            from google import genai
            from google.genai.types import GenerateContentConfig, GoogleSearch, Tool
            
            client = genai.Client()
            
            search_query = f"{pair} cryptocurrency price prediction sentiment today news"
            
            grounding_config = GenerateContentConfig(
                tools=[Tool(google_search=GoogleSearch())],
                temperature=0.3
            )
            
            response = client.models.generate_content(
                model="gemini-2.5-flash",
                contents=search_query,
                config=grounding_config
            )
            
            market_context = response.text[:1500] if response.text else ""
            
            sentiment_prompt = f"""Based on this market context, determine sentiment for {pair}:

{market_context}

Respond with JSON only:
{{"sentiment": "BULLISH" or "BEARISH" or "NEUTRAL", "confidence": 0.0-1.0, "key_factor": "main reason"}}"""
            
            json_config = GenerateContentConfig(
                temperature=0.1,
                response_mime_type="application/json"
            )
            
            result = client.models.generate_content(
                model="gemini-2.5-flash",
                contents=sentiment_prompt,
                config=json_config
            )
            
            data = json.loads(result.text)
            
            signal = "LONG" if data["sentiment"] == "BULLISH" else "SHORT" if data["sentiment"] == "BEARISH" else "NEUTRAL"
            
            return {
                "persona": self.name,
                "signal": signal,
                "confidence": data.get("confidence", 0.5),
                "reasoning": data.get("key_factor", "Market sentiment analysis"),
                "sentiment": data["sentiment"],
                "market_context": market_context[:800],
            }
            
        except Exception as e:
            return {
                "persona": self.name,
                "signal": "NEUTRAL",
                "confidence": 0.3,
                "reasoning": f"Sentiment analysis error: {str(e)}",
            }


# ============================================================
# PERSONA 3: ORDER FLOW
# ============================================================

class FlowPersona:
    """Analyzes order flow (taker ratio, depth)."""
    
    def __init__(self):
        self.name = "FLOW"
        self.weight = 1.0
    
    def analyze(self, pair: str, pair_info: Dict) -> Dict:
        symbol = pair_info["symbol"]
        
        try:
            depth = self._get_order_book_depth(symbol)
            taker_ratio = self._get_taker_ratio(symbol)
            funding = self._get_funding_rate(symbol)
            
            signals = []
            
            if depth["bid_strength"] > 1.3:
                signals.append(("LONG", 0.6, "Strong bid depth"))
            elif depth["ask_strength"] > 1.3:
                signals.append(("SHORT", 0.6, "Strong ask depth"))
            
            if taker_ratio > 1.2:
                signals.append(("LONG", 0.5, f"Taker buy pressure: {taker_ratio:.2f}"))
            elif taker_ratio < 0.8:
                signals.append(("SHORT", 0.5, f"Taker sell pressure: {taker_ratio:.2f}"))
            
            if funding > 0.0005:
                signals.append(("SHORT", 0.4, f"High funding: {funding:.4f}"))
            elif funding < -0.0003:
                signals.append(("LONG", 0.4, f"Negative funding: {funding:.4f}"))
            
            if not signals:
                return {
                    "persona": self.name,
                    "signal": "NEUTRAL",
                    "confidence": 0.3,
                    "reasoning": "No clear flow signal",
                }
            
            long_score = sum(s[1] for s in signals if s[0] == "LONG")
            short_score = sum(s[1] for s in signals if s[0] == "SHORT")
            
            if long_score > short_score and long_score > 0.5:
                return {
                    "persona": self.name,
                    "signal": "LONG",
                    "confidence": min(0.75, long_score),
                    "reasoning": "; ".join(s[2] for s in signals if s[0] == "LONG"),
                }
            elif short_score > long_score and short_score > 0.5:
                return {
                    "persona": self.name,
                    "signal": "SHORT",
                    "confidence": min(0.75, short_score),
                    "reasoning": "; ".join(s[2] for s in signals if s[0] == "SHORT"),
                }
            
            return {
                "persona": self.name,
                "signal": "NEUTRAL",
                "confidence": 0.4,
                "reasoning": "Mixed flow signals",
            }
            
        except Exception as e:
            return {
                "persona": self.name,
                "signal": "NEUTRAL",
                "confidence": 0.0,
                "reasoning": f"Flow analysis error: {str(e)}",
            }
    
    def _get_order_book_depth(self, symbol: str) -> Dict:
        try:
            # WEEX uses limit=15 or limit=200
            url = f"{WEEX_BASE_URL}/capi/v2/market/depth?symbol={symbol}&limit=15"
            r = requests.get(url, timeout=10)
            data = r.json()
            
            bids = data.get("bids", [])
            asks = data.get("asks", [])
            
            # WEEX format: [[price, quantity], ...]
            bid_volume = sum(float(b[1]) for b in bids[:10]) if bids else 0
            ask_volume = sum(float(a[1]) for a in asks[:10]) if asks else 0
            
            ratio = bid_volume / ask_volume if ask_volume > 0 else 1.0
            
            print(f"  [FLOW] Depth - Bids: {bid_volume:.2f}, Asks: {ask_volume:.2f}, Ratio: {ratio:.2f}")
            
            return {
                "bid_volume": bid_volume,
                "ask_volume": ask_volume,
                "bid_strength": ratio,
                "ask_strength": 1/ratio if ratio > 0 else 1.0,
            }
        except Exception as e:
            print(f"  [FLOW] Depth error: {e}")
            return {"bid_strength": 1.0, "ask_strength": 1.0}
    
    def _get_taker_ratio(self, symbol: str) -> float:
        try:
            url = f"{WEEX_BASE_URL}/capi/v2/market/trades?symbol={symbol}&limit=100"
            r = requests.get(url, timeout=10)
            data = r.json()
            
            if isinstance(data, list) and len(data) > 0:
                # WEEX uses isBuyerMaker: true = seller was taker, false = buyer was taker
                buyer_taker_vol = sum(float(t.get("size", 0)) for t in data if not t.get("isBuyerMaker", True))
                seller_taker_vol = sum(float(t.get("size", 0)) for t in data if t.get("isBuyerMaker", False))
                
                total = buyer_taker_vol + seller_taker_vol
                if total > 0:
                    ratio = buyer_taker_vol / seller_taker_vol if seller_taker_vol > 0 else 2.0
                    print(f"  [FLOW] Taker - Buy: {buyer_taker_vol:.4f}, Sell: {seller_taker_vol:.4f}, Ratio: {ratio:.2f}")
                    return ratio
        except Exception as e:
            print(f"  [FLOW] Taker error: {e}")
        return 1.0
    
    def _get_funding_rate(self, symbol: str) -> float:
        try:
            url = f"{WEEX_BASE_URL}/capi/v2/market/currentFundRate?symbol={symbol}"
            r = requests.get(url, timeout=10)
            data = r.json()
            if isinstance(data, list) and len(data) > 0:
                rate = float(data[0].get("fundingRate", 0))
                print(f"  [FLOW] Funding rate: {rate:.6f}")
                return rate
        except Exception as e:
            print(f"  [FLOW] Funding error: {e}")
        return 0.0


# ============================================================
# PERSONA 4: TECHNICAL ANALYSIS
# ============================================================

class TechnicalPersona:
    """Simple technical indicators (RSI, SMA, momentum)."""
    
    def __init__(self):
        self.name = "TECHNICAL"
        self.weight = 1.2  # V3.1.6: Increased from 0.8
    
    def analyze(self, pair: str, pair_info: Dict) -> Dict:
        symbol = pair_info["symbol"]
        
        try:
            candles = self._get_candles(symbol, "1H", 50)
            
            if len(candles) < 20:
                return {
                    "persona": self.name,
                    "signal": "NEUTRAL",
                    "confidence": 0.0,
                    "reasoning": "Insufficient data",
                }
            
            closes = [c["close"] for c in candles]
            
            rsi = self._calculate_rsi(closes, 14)
            sma_20 = np.mean(closes[-20:])
            sma_50 = np.mean(closes[-50:]) if len(closes) >= 50 else sma_20
            current_price = closes[-1]
            
            momentum = (closes[-1] - closes[-5]) / closes[-5] * 100 if closes[-5] > 0 else 0
            
            signals = []
            
            if rsi < 30:
                signals.append(("LONG", 0.7, f"RSI oversold: {rsi:.1f}"))
            elif rsi > 70:
                signals.append(("SHORT", 0.7, f"RSI overbought: {rsi:.1f}"))
            
            if current_price > sma_20 > sma_50:
                signals.append(("LONG", 0.5, "Price above SMAs (uptrend)"))
            elif current_price < sma_20 < sma_50:
                signals.append(("SHORT", 0.5, "Price below SMAs (downtrend)"))
            
            if momentum > 2:
                signals.append(("LONG", 0.4, f"Strong momentum: +{momentum:.1f}%"))
            elif momentum < -2:
                signals.append(("SHORT", 0.4, f"Weak momentum: {momentum:.1f}%"))
            
            if not signals:
                return {
                    "persona": self.name,
                    "signal": "NEUTRAL",
                    "confidence": 0.4,
                    "reasoning": f"No clear technical signal. RSI: {rsi:.1f}",
                }
            
            long_score = sum(s[1] for s in signals if s[0] == "LONG")
            short_score = sum(s[1] for s in signals if s[0] == "SHORT")
            
            if long_score > short_score:
                return {
                    "persona": self.name,
                    "signal": "LONG",
                    "confidence": min(0.8, long_score),
                    "reasoning": "; ".join(s[2] for s in signals if s[0] == "LONG"),
                }
            elif short_score > long_score:
                return {
                    "persona": self.name,
                    "signal": "SHORT",
                    "confidence": min(0.8, short_score),
                    "reasoning": "; ".join(s[2] for s in signals if s[0] == "SHORT"),
                }
            
            return {
                "persona": self.name,
                "signal": "NEUTRAL",
                "confidence": 0.4,
                "reasoning": "Mixed technical signals",
            }
            
        except Exception as e:
            return {
                "persona": self.name,
                "signal": "NEUTRAL",
                "confidence": 0.0,
                "reasoning": f"Technical analysis error: {str(e)}",
            }
    
    def _get_candles(self, symbol: str, interval: str, limit: int) -> List[Dict]:
        try:
            # WEEX uses 'granularity' not 'period', and format like '1h' not '1H'
            granularity = interval.lower()  # '1H' -> '1h'
            url = f"{WEEX_BASE_URL}/capi/v2/market/candles?symbol={symbol}&granularity={granularity}&limit={limit}"
            r = requests.get(url, timeout=10)
            data = r.json()
            
            if isinstance(data, list) and len(data) > 0:
                # WEEX candle format: [timestamp, open, high, low, close, volume, value]
                # Index: 0=time, 1=open, 2=high, 3=low, 4=close, 5=volume, 6=value
                candles = []
                for c in data:
                    if len(c) >= 5:
                        candles.append({
                            "close": float(c[4]),
                            "high": float(c[2]),
                            "low": float(c[3]),
                            "open": float(c[1]),
                            "volume": float(c[5]) if len(c) > 5 else 0
                        })
                return candles
        except Exception as e:
            print(f"  [TECHNICAL] Candle fetch error: {e}")
        return []
    
    def _calculate_rsi(self, prices: List[float], period: int = 14) -> float:
        if len(prices) < period + 1:
            return 50.0
        
        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        
        avg_gain = np.mean(gains[-period:])
        avg_loss = np.mean(losses[-period:])
        
        if avg_loss == 0:
            return 100.0
        
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))


# ============================================================
# JUDGE: FINAL DECISION MAKER (V3.1.4 - Market Trend Filter)
# ============================================================

class JudgePersona:
    """Weighs all persona votes and makes final decision with tier-based TP/SL.
    
    V3.1.4: Added MARKET TREND FILTER - don't go against BTC trend!
    """
    
    def __init__(self):
        self.name = "JUDGE"
        self._btc_trend_cache = {"trend": None, "timestamp": 0}
    
    def _get_btc_trend(self) -> str:
        """Check BTC 4h trend - returns 'UP', 'DOWN', or 'NEUTRAL'
        
        This prevents going LONG on altcoins when BTC is dumping,
        or going SHORT when BTC is pumping.
        """
        import time as time_module
        
        # Cache for 15 minutes
        if time_module.time() - self._btc_trend_cache["timestamp"] < 900:
            return self._btc_trend_cache["trend"]
        
        try:
            # Get BTC 4h candles
            url = f"{WEEX_BASE_URL}/capi/v2/market/candles?symbol=cmt_btcusdt&granularity=4h&limit=6"
            r = requests.get(url, timeout=10)
            data = r.json()
            
            if isinstance(data, list) and len(data) >= 3:
                # Get last 3 candles closes (most recent first)
                closes = [float(c[4]) for c in data[:3]]
                
                # Calculate 4h change
                if len(closes) >= 2:
                    change_pct = ((closes[0] - closes[1]) / closes[1]) * 100
                    
                    if change_pct > 1.0:  # BTC up more than 1% in 4h
                        trend = "UP"
                    elif change_pct < -1.0:  # BTC down more than 1% in 4h
                        trend = "DOWN"
                    else:
                        trend = "NEUTRAL"
                    
                    self._btc_trend_cache = {"trend": trend, "timestamp": time_module.time()}
                    print(f"  [JUDGE] BTC 4h trend: {trend} ({change_pct:+.2f}%)")
                    return trend
        except Exception as e:
            print(f"  [JUDGE] BTC trend check error: {e}")
        
        return "NEUTRAL"
    
    def decide(self, persona_votes: List[Dict], pair: str, balance: float, 
               competition_status: Dict) -> Dict:
        """Make final trading decision with TIER-BASED TP/SL and MARKET TREND FILTER"""
        
        # Get tier config for this pair
        tier_config = get_tier_config_for_pair(pair)
        tier = get_tier_for_pair(pair)
        
        # Calculate weighted votes
        long_score = 0
        short_score = 0
        neutral_score = 0
        
        vote_summary = []
        
        # V3.1.6: Count raw votes for agreement check
        long_votes = 0
        short_votes = 0
        
        for vote in persona_votes:
            persona = vote["persona"]
            signal = vote["signal"]
            confidence = vote["confidence"]
            
            weights = {"WHALE": 2.0, "SENTIMENT": 1.5, "FLOW": 1.0, "TECHNICAL": 1.2}  # V3.1.6
            weight = weights.get(persona, 1.0)
            
            weighted_conf = confidence * weight
            
            if signal == "LONG":
                long_score += weighted_conf
                long_votes += 1
            elif signal == "SHORT":
                short_score += weighted_conf
                short_votes += 1
            else:
                neutral_score += weighted_conf
            
            vote_summary.append(f"{persona}={signal}({confidence:.0%})")
        
        total = long_score + short_score + neutral_score
        
        if total == 0:
            return self._wait_decision("No valid persona votes", persona_votes, vote_summary)
        
        long_pct = long_score / total
        short_pct = short_score / total
        
        # V3.1.4: STRICTER THRESHOLDS
        num_votes = len(persona_votes)
        threshold = 0.40 if num_votes <= 3 else 0.45  # INCREASED from 0.35/0.40
        ratio_req = 1.2 if num_votes <= 3 else 1.25   # INCREASED from 1.1/1.15
        
        if long_pct > threshold and long_score > short_score * ratio_req:
            decision = "LONG"
            confidence = min(0.90, long_pct)
            agreeing_votes = long_votes
            opposing_votes = short_votes
        elif short_pct > threshold and short_score > long_score * ratio_req:
            decision = "SHORT"
            confidence = min(0.90, short_pct)
            agreeing_votes = short_votes
            opposing_votes = long_votes
        else:
            return self._wait_decision(f"No consensus: LONG={long_pct:.0%}, SHORT={short_pct:.0%}", persona_votes, vote_summary)
        
        # V3.1.6: TIER 3 MULTI-PERSONA AGREEMENT
        if tier == 3:
            if agreeing_votes < 2:
                return self._wait_decision(f"Tier 3 requires 2+ agreeing votes (only {agreeing_votes} {decision})", persona_votes, vote_summary)
            if opposing_votes >= 2:
                return self._wait_decision(f"Tier 3 blocked: {opposing_votes} personas oppose {decision}", persona_votes, vote_summary)
        
        # V3.1.6: Tier-specific confidence
        min_confidence = MIN_CONFIDENCE_TO_TRADE
        if tier == 3:
            min_confidence = 0.70  # Higher for meme coins
        
        if confidence < min_confidence:
            return self._wait_decision(f"Confidence too low: {confidence:.0%} (Tier {tier} needs {min_confidence:.0%})", persona_votes, vote_summary)
        
        # V3.1.4: MARKET TREND FILTER - Don't fight the trend!
        if pair != "BTC":  # Don't check BTC against itself
            btc_trend = self._get_btc_trend()
            
            if decision == "LONG" and btc_trend == "DOWN":
                return self._wait_decision(f"BLOCKED: LONG signal but BTC trending DOWN. Don't fight the market!", persona_votes, vote_summary)
            
            if decision == "SHORT" and btc_trend == "UP":
                # Less strict for shorts - only block if very strong uptrend
                # This allows shorting during mild uptrends (mean reversion)
                pass  # Allow shorts even in uptrend for now
        
        # Position sizing
        base_size = balance * 0.07
        
        if confidence > 0.80:
            position_usdt = base_size * 1.5
        elif confidence > 0.70:
            position_usdt = base_size * 1.3
        elif confidence > 0.60:
            position_usdt = base_size * 1.0
        else:
            position_usdt = base_size * 0.8
        
        position_usdt = max(position_usdt, balance * MIN_SINGLE_POSITION_PCT)
        position_usdt = min(position_usdt, balance * MAX_SINGLE_POSITION_PCT)
        
        # V3.1.4: TIER-BASED TP/SL
        tp_pct = tier_config["tp_pct"]
        sl_pct = tier_config["sl_pct"]
        max_hold = tier_config["max_hold_hours"]
        
        return {
            "decision": decision,
            "confidence": confidence,
            "recommended_position_usdt": position_usdt,
            "take_profit_percent": tp_pct,
            "stop_loss_percent": sl_pct,
            "hold_time_hours": max_hold,
            "tier": tier,
            "tier_name": tier_config["name"],
            "reasoning": f"Judge: {decision} @ {confidence:.0%}. Tier {tier} ({tier_config['name']}): TP {tp_pct}%, SL {sl_pct}%, Hold {max_hold}h. Votes: {', '.join(vote_summary)}",
            "persona_votes": persona_votes,
            "vote_breakdown": {
                "long_score": round(long_score, 2),
                "short_score": round(short_score, 2),
                "neutral_score": round(neutral_score, 2),
            },
        }
    
    def _wait_decision(self, reason: str, persona_votes: List[Dict] = None, vote_summary: List[str] = None) -> Dict:
        """Return WAIT decision with full vote details for logging"""
        votes_str = ', '.join(vote_summary) if vote_summary else "No votes"
        return {
            "decision": "WAIT",
            "confidence": 0.0,
            "reasoning": f"{reason}. Votes: {votes_str}",
            "persona_votes": persona_votes or [],
            "vote_summary": vote_summary or [],
        }


# ============================================================
# MULTI-PERSONA ANALYZER
# ============================================================

class MultiPersonaAnalyzer:
    """Coordinates all personas and produces final signal."""
    
    def __init__(self):
        self.whale = WhalePersona()
        self.sentiment = SentimentPersona()
        self.flow = FlowPersona()
        self.technical = TechnicalPersona()
        self.judge = JudgePersona()
    
    def analyze(self, pair: str, pair_info: Dict, balance: float, 
                competition_status: Dict, open_positions: List[Dict]) -> Dict:
        """Run all personas and get final decision"""
        
        tier = pair_info.get("tier", 2)
        tier_config = get_tier_config(tier)
        
        print(f"\n  === Multi-Persona Analysis: {pair} (Tier {tier}: {tier_config['name']}) ===")
        
        votes = []
        
        # 1. Whale Persona (ONLY for ETH/BTC)
        if pair in ("ETH", "BTC"):
            print(f"  [WHALE] Analyzing...")
            whale_vote = self.whale.analyze(pair, pair_info)
            votes.append(whale_vote)
            print(f"  [WHALE] {whale_vote['signal']} ({whale_vote['confidence']:.0%}): {whale_vote['reasoning']}")
        else:
            print(f"  [WHALE] Skipped (no whale data for {pair})")
        
        # 2. Sentiment Persona
        print(f"  [SENTIMENT] Analyzing...")
        sentiment_vote = self.sentiment.analyze(pair, pair_info, competition_status)
        votes.append(sentiment_vote)
        print(f"  [SENTIMENT] {sentiment_vote['signal']} ({sentiment_vote['confidence']:.0%}): {sentiment_vote['reasoning']}")
        
        # 3. Flow Persona
        print(f"  [FLOW] Analyzing...")
        flow_vote = self.flow.analyze(pair, pair_info)
        votes.append(flow_vote)
        print(f"  [FLOW] {flow_vote['signal']} ({flow_vote['confidence']:.0%}): {flow_vote['reasoning']}")
        
        # 4. Technical Persona
        print(f"  [TECHNICAL] Analyzing...")
        tech_vote = self.technical.analyze(pair, pair_info)
        votes.append(tech_vote)
        print(f"  [TECHNICAL] {tech_vote['signal']} ({tech_vote['confidence']:.0%}): {tech_vote['reasoning']}")
        
        # 5. Judge makes final decision
        print(f"  [JUDGE] Deciding...")
        final = self.judge.decide(votes, pair, balance, competition_status)
        print(f"  [JUDGE] Final: {final['decision']} ({final.get('confidence', 0):.0%})")
        
        if final['decision'] in ("LONG", "SHORT"):
            print(f"  [JUDGE] TP: {final.get('take_profit_percent')}%, SL: {final.get('stop_loss_percent')}%, Max Hold: {final.get('hold_time_hours')}h")
        
        return final


# ============================================================
# COMPETITION STATUS
# ============================================================

def get_competition_status(balance: float) -> Dict:
    """Get competition status (phase tracking only, TP/SL now tier-based)"""
    now = datetime.now(timezone.utc)
    days_left = (COMPETITION_END - now).days
    pnl = balance - STARTING_BALANCE
    pnl_pct = (pnl / STARTING_BALANCE) * 100
    
    if days_left > 15:
        phase = "early"
        strategy = "growth"
    elif days_left > 7:
        phase = "mid"
        strategy = "balanced"
    elif days_left > 3:
        phase = "late"
        strategy = "conservative"
    else:
        phase = "final"
        strategy = "protect" if pnl > 0 else "push"
    
    return {
        "days_left": days_left,
        "phase": phase,
        "strategy_mode": strategy,
        "pnl": pnl,
        "pnl_pct": pnl_pct,
    }


# ============================================================
# ORDER PLACEMENT
# ============================================================

def set_leverage(symbol: str, leverage: int) -> Dict:
    endpoint = "/capi/v2/account/leverage"
    body = json.dumps({"symbol": symbol, "leverage": leverage})
    r = requests.post(f"{WEEX_BASE_URL}{endpoint}", headers=weex_headers("POST", endpoint, body), data=body, timeout=15)
    return r.json()


def place_order(symbol: str, side: str, size: float, tp_price: float = None, sl_price: float = None) -> Dict:
    endpoint = "/capi/v2/order/placeOrder"
    rounded_size = round_size_to_step(size, symbol)
    current_price = get_price(symbol)
    
    if tp_price and current_price > 0:
        if side in ("1", "4"):
            limit_price = round_price_to_tick(current_price * 1.002, symbol)
        else:
            limit_price = round_price_to_tick(current_price * 0.998, symbol)
        
        order = {
            "symbol": symbol,
            "client_oid": f"smtv311_{int(time.time()*1000)}",
            "size": str(rounded_size),
            "type": side,
            "order_type": "0",
            "match_price": "0",
            "price": str(limit_price),
        }
        if tp_price:
            order["presetTakeProfitPrice"] = str(round_price_to_tick(tp_price, symbol))
        if sl_price:
            order["presetStopLossPrice"] = str(round_price_to_tick(sl_price, symbol))
    else:
        order = {
            "symbol": symbol,
            "client_oid": f"smtv311_{int(time.time()*1000)}",
            "size": str(rounded_size),
            "type": side,
            "order_type": "0",
            "match_price": "1"
        }
    
    body = json.dumps(order)
    
    if TEST_MODE:
        print(f"  [TEST] Would place: {order}")
        return {"order_id": f"test_{int(time.time())}", "test_mode": True}
    
    r = requests.post(f"{WEEX_BASE_URL}{endpoint}", headers=weex_headers("POST", endpoint, body), data=body, timeout=15)
    return r.json()


# ============================================================
# AI LOG UPLOAD
# ============================================================

def upload_ai_log_to_weex(stage: str, input_data: Dict, output_data: Dict, 
                          explanation: str, order_id: int = None) -> Dict:
    """
    Upload AI decision log to WEEX
    
    V3.1.5 FIX: Proper error logging and response validation
    - Uses flush=True for immediate output visibility in daemon.log
    - Checks WEEX response code ("00000" = success)
    - Logs detailed error info when upload fails
    """
    endpoint = "/capi/v2/order/uploadAiLog"
    
    payload = {
        "stage": stage,
        "model": MODEL_NAME,
        "input": input_data,
        "output": output_data,
        "explanation": explanation[:1000]  # WEEX allows 500 words (~2500 chars)
    }
    
    if order_id:
        payload["orderId"] = int(order_id)
    
    body = json.dumps(payload)
    
    if TEST_MODE:
        print(f"  [AI LOG TEST] Would upload: {stage}", flush=True)
        return {"test_mode": True, "code": "00000"}
    
    try:
        r = requests.post(
            f"{WEEX_BASE_URL}{endpoint}",
            headers=weex_headers("POST", endpoint, body),
            data=body,
            timeout=15
        )
        
        result = r.json()
        code = result.get("code", "unknown")
        msg = result.get("msg", "")
        
        if code == "00000":
            # SUCCESS
            order_str = f" (order: {order_id})" if order_id else ""
            print(f"  [AI LOG OK] {stage}{order_str}", flush=True)
        else:
            # FAILURE - log detailed error
            print(f"  [AI LOG FAIL] {stage}", flush=True)
            print(f"  [AI LOG FAIL] code={code}, msg={msg}", flush=True)
        
        sys.stdout.flush()
        return result
        
    except requests.exceptions.Timeout:
        print(f"  [AI LOG TIMEOUT] {stage}", flush=True)
        sys.stdout.flush()
        return {"error": "timeout", "code": "timeout"}
    except requests.exceptions.RequestException as e:
        print(f"  [AI LOG NET ERROR] {stage}: {e}", flush=True)
        sys.stdout.flush()
        return {"error": str(e), "code": "network_error"}
    except Exception as e:
        print(f"  [AI LOG ERROR] {stage}: {type(e).__name__}: {e}", flush=True)
        sys.stdout.flush()
        return {"error": str(e), "code": "unknown"}


# ============================================================
# TRADE EXECUTION (V3.1.1 - Tier-Based)
# ============================================================

def execute_trade(pair_info: Dict, decision: Dict, balance: float) -> Dict:
    """Execute trade with TIER-BASED TP/SL"""
    
    symbol = pair_info["symbol"]
    signal = decision["decision"]
    tier = pair_info.get("tier", 2)
    tier_config = get_tier_config(tier)
    
    if signal not in ("LONG", "SHORT"):
        return {"executed": False, "reason": "No trade signal"}
    
    current_price = get_price(symbol)
    if current_price == 0:
        return {"executed": False, "reason": "Could not get price"}
    
    position_usdt = decision.get("recommended_position_usdt", balance * 0.07)
    position_usdt = max(position_usdt, balance * MIN_SINGLE_POSITION_PCT)
    position_usdt = min(position_usdt, balance * MAX_SINGLE_POSITION_PCT)
    
    notional_usdt = position_usdt * MAX_LEVERAGE
    raw_size = notional_usdt / current_price
    
    if raw_size <= 0:
        return {"executed": False, "reason": f"Invalid size: {raw_size}"}
    
    size = round_size_to_step(raw_size, symbol)
    
    if size <= 0:
        return {"executed": False, "reason": f"Size too small: {size}"}
    
    order_type = "1" if signal == "LONG" else "2"
    
    # V3.1.1: Use tier-based TP/SL from decision (set by Judge)
    tp_pct = decision.get("take_profit_percent", tier_config["tp_pct"]) / 100
    sl_pct = decision.get("stop_loss_percent", tier_config["sl_pct"]) / 100
    
    if signal == "LONG":
        tp_price = current_price * (1 + tp_pct)
        sl_price = current_price * (1 - sl_pct)
    else:
        tp_price = current_price * (1 - tp_pct)
        sl_price = current_price * (1 + sl_pct)
    
    set_leverage(symbol, MAX_LEVERAGE)
    
    print(f"  [TRADE] {signal} {symbol}: {size} @ ${current_price:.4f}")
    print(f"  [TRADE] Tier {tier} ({tier_config['name']}): TP ${tp_price:.4f} ({tp_pct*100:.1f}%), SL ${sl_price:.4f} ({sl_pct*100:.1f}%)")
    
    result = place_order(symbol, order_type, size, tp_price, sl_price)
    
    order_id = result.get("order_id")
    
    if not order_id:
        return {"executed": False, "reason": f"Order failed: {result}"}
    
    # Upload AI log
    upload_ai_log_to_weex(
        stage=f"V3.1.4 Trade: {signal} {symbol.replace('cmt_', '').upper()}",
        input_data={
            "pair": symbol,
            "balance": balance,
            "tier": tier,
            "tier_name": tier_config["name"],
        },
        output_data={
            "signal": signal,
            "confidence": decision["confidence"],
            "size": size,
            "entry_price": current_price,
            "tp_price": tp_price,
            "sl_price": sl_price,
            "tp_pct": tp_pct * 100,
            "sl_pct": sl_pct * 100,
        },
        explanation=decision.get("reasoning", "")[:2500],  # WEEX allows 500 words
        order_id=int(order_id) if str(order_id).isdigit() else None
    )
    
    return {
        "executed": True,
        "order_id": order_id,
        "symbol": symbol,
        "signal": signal,
        "size": size,
        "entry_price": current_price,
        "tp_price": tp_price,
        "sl_price": sl_price,
        "tp_pct": tp_pct * 100,
        "sl_pct": sl_pct * 100,
        "position_usdt": position_usdt,
        "tier": tier,
        "tier_name": tier_config["name"],
        "max_hold_hours": tier_config["max_hold_hours"],
    }


# ============================================================
# TRADE TRACKER (with Cooldown for Losing Trades)
# ============================================================

# Cooldown periods by tier (prevents revenge trading)
COOLDOWN_HOURS = {
    1: 6,   # Tier 1 (BTC, ETH, BNB, LTC): 6 hour cooldown
    2: 8,   # Tier 2 (SOL): 8 hour cooldown  
    3: 12,  # Tier 3 (DOGE, XRP, ADA): 12 hour cooldown (2x max hold time)
}

# ============================================================
# V3.1.2: RUNNER LOGIC CONFIGURATION
# ============================================================
# When position hits 50% of TP, close half and let rest run
# Only for Tier 1 and Tier 2 - Tier 3 is scalp only

RUNNER_CONFIG = {
    1: {  # BTC, ETH, BNB, LTC
        "enabled": True,
        "trigger_pct": 2.0,      # Trigger at +2% (50% of 4% TP)
        "close_pct": 50,         # Close 50% of position
        "move_sl_to_entry": True,  # Move SL to breakeven
        "remove_tp": True,       # Let remaining 50% run
    },
    2: {  # SOL
        "enabled": True,
        "trigger_pct": 1.5,      # Trigger at +1.5% (50% of 3% TP)
        "close_pct": 50,
        "move_sl_to_entry": True,
        "remove_tp": True,
    },
    3: {  # DOGE, XRP, ADA - NO RUNNERS (too volatile)
        "enabled": False,
    },
}


def get_runner_config(tier: int) -> Dict:
    """Get runner configuration for a tier"""
    return RUNNER_CONFIG.get(tier, {"enabled": False})

class TradeTracker:
    def __init__(self, state_file: str = "trade_state_v3_1.json"):
        self.state_file = state_file
        self.active_trades: Dict = {}
        self.closed_trades: List = []
        self.cooldowns: Dict = {}  # symbol -> cooldown_until timestamp
        self.load_state()
    
    def load_state(self):
        try:
            if os.path.exists(self.state_file):
                with open(self.state_file, 'r') as f:
                    data = json.load(f)
                    self.active_trades = data.get("active", {})
                    self.closed_trades = data.get("closed", [])
                    self.cooldowns = data.get("cooldowns", {})
        except:
            pass
    
    def save_state(self):
        with open(self.state_file, 'w') as f:
            json.dump({
                "active": self.active_trades, 
                "closed": self.closed_trades,
                "cooldowns": self.cooldowns
            }, f, indent=2, default=str)
    
    def add_trade(self, symbol: str, trade_data: Dict):
        self.active_trades[symbol] = {
            "opened_at": datetime.now(timezone.utc).isoformat(),
            "order_id": trade_data.get("order_id"),
            "side": trade_data.get("signal"),
            "size": trade_data.get("size"),
            "entry_price": trade_data.get("entry_price"),
            "tp_price": trade_data.get("tp_price"),
            "sl_price": trade_data.get("sl_price"),
            "position_usdt": trade_data.get("position_usdt"),
            "tier": trade_data.get("tier"),
            "max_hold_hours": trade_data.get("max_hold_hours"),
        }
        self.save_state()
    
    def close_trade(self, symbol: str, close_data: Dict = None):
        if symbol in self.active_trades:
            trade = self.active_trades.pop(symbol)
            trade["closed_at"] = datetime.now(timezone.utc).isoformat()
            trade["close_data"] = close_data
            self.closed_trades.append(trade)
            
            # Check if it was a losing trade - add cooldown
            pnl_pct = close_data.get("final_pnl_pct", 0) if close_data else 0
            reason = close_data.get("reason", "") if close_data else ""
            
            # Add cooldown if closed at a loss or force-exited
            if pnl_pct < 0 or "early_exit" in reason or "force_stop" in reason or "max_hold" in reason:
                tier = trade.get("tier", 2)
                cooldown_hours = COOLDOWN_HOURS.get(tier, 12)
                cooldown_until = datetime.now(timezone.utc) + timedelta(hours=cooldown_hours)
                self.cooldowns[symbol] = cooldown_until.isoformat()
                print(f"  [COOLDOWN] {symbol} on cooldown for {cooldown_hours}h until {cooldown_until.strftime('%Y-%m-%d %H:%M UTC')}")
            
            self.save_state()
    
    def is_on_cooldown(self, symbol: str) -> bool:
        """Check if a symbol is on cooldown (recently closed at loss)"""
        if symbol not in self.cooldowns:
            return False
        
        try:
            cooldown_until = datetime.fromisoformat(self.cooldowns[symbol].replace("Z", "+00:00"))
            if datetime.now(timezone.utc) < cooldown_until:
                remaining = (cooldown_until - datetime.now(timezone.utc)).total_seconds() / 3600
                print(f"  [COOLDOWN] {symbol} still on cooldown ({remaining:.1f}h remaining)")
                return True
            else:
                # Cooldown expired, remove it
                del self.cooldowns[symbol]
                self.save_state()
                return False
        except:
            return False
    
    def get_cooldown_remaining(self, symbol: str) -> float:
        """Get remaining cooldown hours for a symbol"""
        if symbol not in self.cooldowns:
            return 0
        
        try:
            cooldown_until = datetime.fromisoformat(self.cooldowns[symbol].replace("Z", "+00:00"))
            remaining = (cooldown_until - datetime.now(timezone.utc)).total_seconds() / 3600
            return max(0, remaining)
        except:
            return 0
    
    def get_active_symbols(self) -> List[str]:
        return list(self.active_trades.keys())
    
    def get_active_trade(self, symbol: str) -> Optional[Dict]:
        return self.active_trades.get(symbol)


# ============================================================
# POSITION MANAGEMENT
# ============================================================

def check_position_status(symbol: str) -> Dict:
    positions = get_open_positions()
    for pos in positions:
        if pos["symbol"] == symbol:
            return {
                "is_open": True,
                "side": pos["side"],
                "size": pos["size"],
                "entry_price": pos["entry_price"],
                "unrealized_pnl": pos["unrealized_pnl"],
            }
    return {"is_open": False}


def cancel_all_orders_for_symbol(symbol: str) -> Dict:
    """Cancel all pending orders for a symbol"""
    result = {"cancelled": []}
    
    try:
        endpoint = "/capi/v2/order/orders"
        if symbol:
            endpoint += f"?symbol={symbol}"
        r = requests.get(f"{WEEX_BASE_URL}{endpoint}", headers=weex_headers("GET", endpoint), timeout=15)
        orders = r.json() if isinstance(r.json(), list) else []
        
        for order in orders:
            oid = order.get("order_id")
            if oid:
                cancel_endpoint = "/capi/v2/order/cancel"
                body = json.dumps({"order_id": oid})
                requests.post(f"{WEEX_BASE_URL}{cancel_endpoint}", 
                            headers=weex_headers("POST", cancel_endpoint, body), 
                            data=body, timeout=15)
                result["cancelled"].append(oid)
    except:
        pass
    
    try:
        endpoint = "/capi/v2/order/plan_orders"
        if symbol:
            endpoint += f"?symbol={symbol}"
        r = requests.get(f"{WEEX_BASE_URL}{endpoint}", headers=weex_headers("GET", endpoint), timeout=15)
        orders = r.json() if isinstance(r.json(), list) else []
        
        for order in orders:
            oid = order.get("order_id")
            if oid:
                cancel_endpoint = "/capi/v2/order/cancel_plan"
                body = json.dumps({"order_id": oid})
                requests.post(f"{WEEX_BASE_URL}{cancel_endpoint}", 
                            headers=weex_headers("POST", cancel_endpoint, body), 
                            data=body, timeout=15)
                result["cancelled"].append(f"plan_{oid}")
    except:
        pass
    
    return result


def close_position_manually(symbol: str, side: str, size: float) -> Dict:
    close_type = "3" if side == "LONG" else "4"
    return place_order(symbol, close_type, size)


def execute_runner_partial_close(symbol: str, side: str, current_size: float, 
                                  entry_price: float, current_price: float) -> Dict:
    """
    Execute Runner Logic: Close 50% of position, move SL to breakeven
    
    V3.1.5 FIX: Cancel old TP/SL orders and place new ones with remaining size
    
    Returns: {"executed": True/False, "closed_size": X, "remaining_size": X, ...}
    """
    tier = get_tier_for_symbol(symbol)
    runner_config = get_runner_config(tier)
    tier_config = get_tier_config(tier)
    
    if not runner_config.get("enabled"):
        return {"executed": False, "reason": "Runner not enabled for this tier"}
    
    # Calculate close size (50% of position)
    close_pct = runner_config.get("close_pct", 50) / 100
    close_size = round_size_to_step(current_size * close_pct, symbol)
    remaining_size = round_size_to_step(current_size - close_size, symbol)
    
    if close_size <= 0:
        return {"executed": False, "reason": "Close size too small"}
    
    # Close 50% at market
    close_type = "3" if side == "LONG" else "4"  # Close long = 3, Close short = 4
    
    print(f"  [RUNNER] Closing {close_pct*100:.0f}% of {symbol}: {close_size} units")
    print(f"  [RUNNER] Entry: ${entry_price:.4f}, Current: ${current_price:.4f}")
    
    # Place partial close order (NO TP/SL on close order)
    close_result = place_order(symbol, close_type, close_size, tp_price=None, sl_price=None)
    
    if not close_result.get("order_id"):
        return {"executed": False, "reason": f"Close order failed: {close_result}"}
    
    # Calculate profit locked
    if side == "LONG":
        profit_per_unit = current_price - entry_price
    else:
        profit_per_unit = entry_price - current_price
    
    profit_locked = profit_per_unit * close_size
    
    # Upload AI log for runner
    upload_ai_log_to_weex(
        stage=f"V3.1.2 Runner: Partial Close {symbol.replace('cmt_', '').upper()}",
        input_data={
            "symbol": symbol,
            "side": side,
            "original_size": current_size,
            "close_size": close_size,
            "remaining_size": remaining_size,
            "entry_price": entry_price,
            "current_price": current_price,
        },
        output_data={
            "profit_locked": profit_locked,
            "close_order_id": close_result.get("order_id"),
        },
        explanation=f"Runner triggered at +{((current_price/entry_price - 1) * 100):.1f}%. Closed {close_pct*100:.0f}% ({close_size} units), locked ${profit_locked:.2f} profit. Remaining {remaining_size} units running free."
    )
    
    # V3.1.5: Cancel old TP/SL orders and place new ones for remaining size
    try:
        # Cancel existing plan orders for this symbol
        plan_endpoint = f'/capi/v2/order/currentPlan?symbol={symbol}'
        r = requests.get(f"{WEEX_BASE_URL}{plan_endpoint}", headers=weex_headers("GET", plan_endpoint), timeout=10)
        old_orders = r.json() if isinstance(r.json(), list) else []
        
        for order in old_orders:
            order_id = order.get('order_id')
            if order_id:
                cancel_endpoint = '/capi/v2/order/cancel_plan'
                cancel_body = json.dumps({'orderId': str(order_id)})
                requests.post(f"{WEEX_BASE_URL}{cancel_endpoint}",
                            headers=weex_headers('POST', cancel_endpoint, cancel_body),
                            data=cancel_body, timeout=10)
                print(f"  [RUNNER] Cancelled old order {order_id}")
        
        # Place new SL order at breakeven (entry price) for remaining size
        if runner_config.get("move_sl_to_entry") and remaining_size > 0:
            new_sl_price = entry_price
            plan_order_endpoint = '/capi/v2/order/plan_order'
            sl_body = json.dumps({
                'symbol': symbol,
                'client_oid': f'smt_runner_sl_{int(time.time()*1000)}',
                'size': str(remaining_size),
                'type': close_type,
                'match_type': '1',
                'execute_price': '0',
                'trigger_price': str(round_price_to_tick(new_sl_price, symbol))
            })
            sl_r = requests.post(f"{WEEX_BASE_URL}{plan_order_endpoint}",
                               headers=weex_headers('POST', plan_order_endpoint, sl_body),
                               data=sl_body, timeout=10)
            print(f"  [RUNNER] New SL at breakeven ${new_sl_price:.2f}: {sl_r.status_code}")
        
        # Place new TP order for remaining size (let it run to full TP)
        if remaining_size > 0:
            tp_pct = tier_config["tp_pct"] / 100
            if side == "LONG":
                new_tp_price = entry_price * (1 + tp_pct)
            else:
                new_tp_price = entry_price * (1 - tp_pct)
            
            tp_body = json.dumps({
                'symbol': symbol,
                'client_oid': f'smt_runner_tp_{int(time.time()*1000)}',
                'size': str(remaining_size),
                'type': close_type,
                'match_type': '1',
                'execute_price': '0',
                'trigger_price': str(round_price_to_tick(new_tp_price, symbol))
            })
            tp_r = requests.post(f"{WEEX_BASE_URL}{plan_order_endpoint}",
                               headers=weex_headers('POST', plan_order_endpoint, tp_body),
                               data=tp_body, timeout=10)
            print(f"  [RUNNER] New TP at ${new_tp_price:.2f}: {tp_r.status_code}")
            
    except Exception as e:
        print(f"  [RUNNER] Warning: Could not update TP/SL orders: {e}")
    
    return {
        "executed": True,
        "closed_size": close_size,
        "remaining_size": remaining_size,
        "profit_locked": profit_locked,
        "close_order_id": close_result.get("order_id"),
        "new_sl_price": entry_price if runner_config.get("move_sl_to_entry") else None,
    }


def save_local_log(log_data: Dict, timestamp: str):
    os.makedirs("logs", exist_ok=True)
    filename = f"logs/v3_1_1_{timestamp}.json"
    with open(filename, 'w') as f:
        json.dump(log_data, f, indent=2, default=str)
    print(f"  [LOG] Saved: {filename}")


# ============================================================
# MAIN (for testing)
# ============================================================

if __name__ == "__main__":
    print("=" * 60)
    print("SMT V3.1.1 - Tier-Based Multi-Persona Trading")
    print("=" * 60)
    
    print("\nTier Configuration:")
    for tier, config in TIER_CONFIG.items():
        pairs = [p for p, info in TRADING_PAIRS.items() if info["tier"] == tier]
        print(f"  Tier {tier} ({config['name']}): {', '.join(pairs)}")
        print(f"    TP: {config['tp_pct']}%, SL: {config['sl_pct']}%, Max Hold: {config['max_hold_hours']}h")
    
    balance = get_balance()
    positions = get_open_positions()
    competition = get_competition_status(balance)
    
    print(f"\nBalance: {balance:.2f} USDT")
    print(f"Positions: {len(positions)}")
    print(f"Phase: {competition['phase']}, Days left: {competition['days_left']}")
    
    # Test analysis on one pair from each tier
    analyzer = MultiPersonaAnalyzer()
    
    for pair in ["BTC", "SOL", "DOGE"]:
        print(f"\n{'='*60}")
        result = analyzer.analyze(pair, TRADING_PAIRS[pair], balance, competition, positions)
        print(f"\nFINAL for {pair}: {result['decision']} ({result.get('confidence', 0):.0%})")
